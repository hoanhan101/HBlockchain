#!/usr/bin/env python
# example of proof-of-work algorithm

import hashlib
import time
# from time import ctime, time

nonce = 0
max_nonce = 2 ** 32 # 4 billion maximum tries


def mine_for_next_block(self):
    """
    Find the nonce of work for the next block and add it to the chain.
    :return:
    """
    # Assume the address of sender and recipient is fixed when mining a block
    reward = {
        'sender': '000000000000000000000000000000x0',
        'recipient': '000000000000000000000000000000x1',
        'amount': self.calculate_block_reward()
    }

    last_block = self.get_last_block()
    last_proof = last_block['nonce']

    # Find nonce for the next block
    next_nonce = self.find_proof_of_work(last_proof)

    # Reward miner
    self.add_transaction(reward['sender'], reward['recipient'], reward['amount'])

    # Add that block to the chain
    self.generate_next_block(next_nonce)


def find_proof_of_work(self, last_proof):
    """
    Return a nonce such that hash of last nonce and this nonce contains leading 4 zeroes.
    :param last_proof: Last nonce number
    :return: Proof number
    """
    # Let nonce number start at 0
    nonce = 0

    # Increase the nonce by 1 until we find the right value
    while self.verify_proof_of_work(last_proof, nonce) is False:
        nonce += 1

    return nonce


def verify_proof_of_work(self, last_proof, nonce):
    """
    Check if the guess hash has 4 zeros in the front.
    :param last_proof: Previous nonce
    :param nonce: Current nonce
    :return: True if correct, False if not.
    """
    guess = '{0}{1}'.format(last_proof, nonce).encode()
    guess_hash = hashlib.sha256(guess).hexdigest()
    return guess_hash[:4] == '0000'

def calculate_proof_of_work(block_header, number_of_bits):
    """
    If we decrease the target, the task of finding a hash that is less than the target becomes more and more difficult.
    :param block_header: Block's block_header
    :param number_of_bits: Number of leading bits as zeros
    :return:
    """
    # Calculate the difficulty target
    target = 2 ** (256 - number_of_bits)

    # Constantly increase nonce by 1 and guess the right nonce
    for nonce in range(max_nonce):
        string = (str(block_header)+str(nonce)).encode()
        hash_result = hashlib.sha256(string).hexdigest()

        # Check if the hash result is below the target
        if int(hash_result, 16) < target:
            print("Hash base 16: {0}".format(hash_result))
            print("Target base 16: {0}".format(hex(target)))
            print("Hash base 10: {0}".format(int(hash_result, 16)))
            print("Target base 10: {0}".format(target))
            print("Nonce: {0}".format(nonce))
            print("\n")
            return (hash_result, nonce)

    print("Failed after {0} tries".format(max_nonce))
    return None

def calculate_level_of_difficulty():
    difficulty_bits = 0


    # when bootup, set difficulty bits = 0, therefore difficulty = 1
    # however, after every 10 blocks

    difficulty = 2 ** difficulty_bits


    block_height = 1
    if block_height % 10 == 0:
        init_difficulty_bits += 1

if __name__ == '__main__':

    hash_result = ''

    # increase the difficulty for every 10 blocks
    # in order to increase the difficulty, need to increase the number of bit
    # increase by 1 bit result in increasing the difficulty exponentially by the power of 2



    for difficulty_bits in range(20):
        # Difficulty increase exponentially by the number of bits
        difficulty = 2 ** difficulty_bits
        print("Difficulty: %ld (%d bits)" % (difficulty, difficulty_bits))

        # print("Starting search...")

        # checkpoint the current time
        # start_time = time.time()

        # make a new block which includes the hash from the previous block
        # we fake a block of transactions - just a string
        new_block = 'test block with transactions' + hash_result

        # find a valid nonce for the new block
        (hash_result, nonce) = calculate_proof_of_work(new_block, difficulty_bits)

        # checkpoint how long it took to find a result
        # end_time = time.time()
        #
        # elapsed_time = end_time - start_time
        # print("Elapsed Time: %.4f seconds" % elapsed_time)
        #
        # if elapsed_time > 0:
        #     # estimate the hashes per second
        #     hash_power = float(int(nonce)/elapsed_time)
        #     print("Hashing Power: %ld hashes per second\n" % hash_power)

    # print('asdasd')
    # nonce = 0
    # max_nonce = 2 ** 32
    #
    # for nonce in range(max_nonce):
    #     test_string = ("Hoanh An" + str(nonce)).encode()
    #     hash_string = hashlib.sha256(test_string).hexdigest()
    #     print(hash_string)

    # print(time())
    # print(ctime(time()))